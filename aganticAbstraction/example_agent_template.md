# Agent Rules Template

**Purpose:** Template for agent.md files generated by the system

---

## Architecture Overview

**System Type:** [MVC / Microservices / Layered / etc.]

**Key Components:**
- Component A: Responsibility
- Component B: Responsibility
- Component C: Responsibility

**Technology Stack:**
- Backend: [Framework/Language]
- Frontend: [Framework/Language]
- Database: [Database type]
- Other: [Tools/Services]

---

## Design Rules

### Rule 1: [Pattern Name]

**What:** [Description of the pattern]

**Why:** [Rationale for using this pattern]

**When:** [When to apply this rule]

**Example:**
```language
// Code example demonstrating the pattern
class Example {
    // Implementation
}
```

**Don't:**
```language
// Anti-pattern example
class BadExample {
    // What NOT to do
}
```

---

## Coding Rules

### Naming Conventions

**Variables:**
- Format: [camelCase / snake_case / etc.]
- Example: `userProfile`, `orderList`

**Functions:**
- Format: [camelCase / snake_case]
- Prefix: [get / set / is / has]
- Example: `getUserProfile()`, `isUserActive()`

**Classes:**
- Format: [PascalCase]
- Suffix: [Manager / Service / Controller]
- Example: `UserManager`, `OrderService`

**Files:**
- Format: [kebab-case / PascalCase]
- Example: `user-profile.ts`, `UserProfile.ts`

### Code Organization

**Rule:** [Organization principle]

**Structure:**
```
src/
  ├── features/
  │   └── [feature-name]/
  │       ├── components/
  │       ├── services/
  │       └── types/
  └── shared/
```

**Example:**
```language
// Well-organized code example
export class UserService {
    // Clear separation of concerns
}
```

### Error Handling

**Pattern:** [try-catch / error boundaries / etc.]

**Rule:** [How to handle errors]

**Example:**
```language
try {
    await riskyOperation();
} catch (error) {
    logger.error('Operation failed', error);
    throw new CustomError('User-friendly message');
}
```

---

## Development Rules

### Adding New Features

**Process:**
1. Create feature branch
2. Follow component structure
3. Add tests
4. Update documentation

**Example:**
```bash
# Create feature
git checkout -b feature/new-feature

# Follow structure
src/features/new-feature/
  ├── components/
  ├── hooks/
  └── index.ts
```

### Modifying Existing Code

**Rule:** Preserve existing patterns

**Checklist:**
- [ ] Maintains existing architecture
- [ ] Follows naming conventions
- [ ] Includes tests
- [ ] Updates documentation

### Testing Requirements

**Coverage:** [Minimum percentage]

**What to test:**
- Unit tests for business logic
- Integration tests for APIs
- E2E tests for critical paths

**Example:**
```language
describe('UserService', () => {
    it('should create user successfully', async () => {
        // Test implementation
    });
});
```

---

## API Rules

### Endpoint Conventions

**Format:** `/api/v{version}/{resource}`

**Example:**
```
GET    /api/v1/users
POST   /api/v1/users
GET    /api/v1/users/:id
PUT    /api/v1/users/:id
DELETE /api/v1/users/:id
```

### Request/Response Format

**Request:**
```json
{
    "data": {
        // Payload
    }
}
```

**Response:**
```json
{
    "success": true,
    "data": {
        // Result
    }
}
```

**Error Response:**
```json
{
    "success": false,
    "error": {
        "code": "ERROR_CODE",
        "message": "User-friendly message"
    }
}
```

---

## Code Examples

### Example 1: [Pattern Name]

**Demonstrates:** [Rules]

**File:** `src/example/file.ts`

```language
// Exemplary code showing best practices
export class WellDesignedClass {
    // Clear, maintainable code
}
```

**Why this is good:**
- Follows naming conventions
- Clear separation of concerns
- Proper error handling
- Well documented

---

## Common Patterns

### Pattern: [Pattern Name]

**Used in:**
- Component A
- Component B

**Implementation:**
```language
// Pattern implementation
```

**Benefits:**
- Benefit 1
- Benefit 2

---

## Anti-Patterns to Avoid

### ❌ Anti-Pattern: [Name]

**Problem:** [What's wrong]

**Instead do:**
```language
// Correct approach
```

---

## Documentation Standards

**Rule:** All public APIs must be documented

**Format:**
```language
/**
 * Brief description of function
 * 
 * @param param1 - Description
 * @param param2 - Description
 * @returns Description of return value
 * @throws ErrorType - When this error occurs
 * 
 * @example
 * ```
 * const result = functionName(arg1, arg2);
 * ```
 */
```

---

## Usage Instructions for AI Agents

### When Adding Features:
1. Review Design Rules
2. Follow Coding Rules
3. Refer to Code Examples
4. Match existing patterns

### When Fixing Bugs:
1. Identify affected component
2. Follow error handling patterns
3. Maintain consistency
4. Add regression test

### When Refactoring:
1. Preserve design patterns
2. Maintain API compatibility
3. Follow naming conventions
4. Update documentation

---

## Key Principles

1. **Consistency** - Match existing code style
2. **Clarity** - Write self-documenting code
3. **Completeness** - Include tests and docs
4. **Context** - Understand the architecture

---

## Exceptions and Special Cases

### When to deviate from rules:
- [Specific scenario]
- [Special case]

**Document exceptions clearly:**
```language
// EXCEPTION: Using different pattern because [reason]
```

---

## Glossary

**Term 1:** Definition  
**Term 2:** Definition  
**Term 3:** Definition  

---

*This template shows the structure of generated agent.md files*
